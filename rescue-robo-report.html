<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RESCUE ROBO - DAA Lab Project Report</title>
    <style>
        /* Page Setup */
        @page {
            size: A4;
            margin: 1in;
        }
        
        body {
            font-family: 'Times New Roman', Times, serif;
            font-size: 12pt;
            line-height: 1.5;
            color: #000000;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 1in;
            background: white;
        }
        
        /* Headings */
        h1 {
            font-family: Arial, sans-serif;
            font-size: 18pt;
            font-weight: bold;
            margin-top: 24pt;
            margin-bottom: 12pt;
            color: #000000;
            text-align: left;
            page-break-after: avoid;
        }
        
        h2 {
            font-family: Arial, sans-serif;
            font-size: 16pt;
            font-weight: bold;
            margin-top: 18pt;
            margin-bottom: 10pt;
            color: #000000;
            page-break-after: avoid;
        }
        
        h3 {
            font-family: Arial, sans-serif;
            font-size: 14pt;
            font-weight: bold;
            margin-top: 14pt;
            margin-bottom: 8pt;
            color: #000000;
            page-break-after: avoid;
        }
        
        h4 {
            font-family: Arial, sans-serif;
            font-size: 12pt;
            font-weight: bold;
            margin-top: 12pt;
            margin-bottom: 6pt;
            color: #000000;
            page-break-after: avoid;
        }
        
        /* Paragraphs */
        p {
            margin-top: 0;
            margin-bottom: 12pt;
            text-align: justify;
        }
        
        /* Lists */
        ul, ol {
            margin-top: 6pt;
            margin-bottom: 12pt;
            padding-left: 40pt;
        }
        
        li {
            margin-bottom: 6pt;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12pt;
            margin-bottom: 12pt;
            page-break-inside: avoid;
        }
        
        table, th, td {
            border: 1px solid #000000;
        }
        
        th {
            background-color: #d9d9d9;
            font-weight: bold;
            padding: 8pt;
            text-align: left;
        }
        
        td {
            padding: 8pt;
            vertical-align: top;
        }
        
        /* Code Blocks */
        pre {
            background-color: #f5f5f5;
            border: 1px solid #cccccc;
            padding: 12pt;
            margin-top: 12pt;
            margin-bottom: 12pt;
            font-family: 'Courier New', Courier, monospace;
            font-size: 10pt;
            line-height: 1.4;
            overflow-x: auto;
            page-break-inside: avoid;
        }
        
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 10pt;
            background-color: #f5f5f5;
            padding: 2pt 4pt;
        }
        
        /* Header Section */
        .header {
            text-align: center;
            margin-bottom: 24pt;
        }
        
        .header h1 {
            margin-top: 12pt;
            margin-bottom: 6pt;
        }
        
        .header p {
            margin: 3pt 0;
            text-align: center;
        }
        
        /* Logo Placeholder */
        .logo-placeholder {
            width: 150px;
            height: 150px;
            border: 2px dashed #666666;
            margin: 0 auto 12pt auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
            font-size: 10pt;
            color: #666666;
        }
        
        /* Member Info Table */
        .member-info {
            margin: 24pt 0;
        }
        
        /* Page Break */
        .page-break {
            page-break-before: always;
        }
        
        /* Figure Caption */
        .figure {
            margin: 12pt 0;
            page-break-inside: avoid;
        }
        
        .figure-box {
            border: 1px solid #cccccc;
            padding: 12pt;
            background-color: #fafafa;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666666;
            font-style: italic;
        }
        
        .caption {
            font-size: 10pt;
            font-style: italic;
            margin-top: 6pt;
            text-align: center;
        }
        
        /* Separator Line */
        hr {
            border: none;
            border-top: 1px solid #000000;
            margin: 12pt 0;
        }
        
        /* Special Formatting */
        .centered {
            text-align: center;
        }
        
        .bold {
            font-weight: bold;
        }
        
        .italic {
            font-style: italic;
        }
        
        /* TOC */
        .toc {
            margin: 24pt 0;
        }
        
        .toc-item {
            margin: 6pt 0;
            padding-left: 20pt;
            text-indent: -20pt;
        }
        
        .toc-h1 {
            font-weight: bold;
            margin-top: 12pt;
        }
        
        .toc-h2 {
            padding-left: 40pt;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            font-size: 10pt;
            margin-top: 24pt;
            padding-top: 12pt;
            border-top: 1px solid #000000;
        }
    </style>
</head>
<body>

<!-- HEADER SECTION -->
<div class="header">
    <div class="logo-placeholder">
        [University Logo]
    </div>
    
    <h1 style="font-size: 16pt; margin-top: 0;">RAMDEOBABA UNIVERSITY, NAGPUR</h1>
    <p class="bold">DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING</p>
    <p>SESSION: 2025-26</p>
    <p style="margin-top: 18pt;">Subject: Design and Analysis of Algorithms (DAA) Lab Project</p>
    <p>III Semester</p>
    
    <h1 style="margin-top: 24pt; font-size: 20pt;">LAB PROJECT REPORT</h1>
</div>

<hr>

<div class="member-info">
    <table>
        <tr>
            <th colspan="4" style="text-align: center; background-color: #b8b8b8;">Project Members</th>
        </tr>
        <tr>
            <td><strong>Name</strong></td>
            <td><strong>Roll No</strong></td>
            <td><strong>Batch</strong></td>
            <td><strong>Section</strong></td>
        </tr>
        <tr>
            <td>Pranav Rathi</td>
            <td>48</td>
            <td>B3</td>
            <td>A5</td>
        </tr>
        <tr>
            <td>Aditya Chapke</td>
            <td>37</td>
            <td>B3</td>
            <td>A5</td>
        </tr>
        <tr>
            <td>Hiten Borkar</td>
            <td>15</td>
            <td>B1</td>
            <td>A5</td>
        </tr>
        <tr>
            <td colspan="4"><strong>Date of Submission:</strong> October 30, 2025</td>
        </tr>
    </table>
</div>

<!-- TABLE OF CONTENTS -->
<div class="page-break"></div>
<h1>TABLE OF CONTENTS</h1>
<div class="toc">
    <div class="toc-item toc-h1">1. TITLE .................................................. 3</div>
    <div class="toc-item toc-h1">2. OBJECTIVES .............................................. 4</div>
    <div class="toc-item toc-h2">2.1 Primary Objectives ................................. 4</div>
    <div class="toc-item toc-h2">2.2 Secondary Objectives ............................... 4</div>
    <div class="toc-item toc-h1">3. INTRODUCTION ............................................ 5</div>
    <div class="toc-item toc-h2">3.1 Background and Motivation .......................... 5</div>
    <div class="toc-item toc-h2">3.2 Problem Statement .................................. 6</div>
    <div class="toc-item toc-h2">3.3 Real-World Applications ............................ 6</div>
    <div class="toc-item toc-h2">3.4 Technology Stack ................................... 7</div>
    <div class="toc-item toc-h2">3.5 Project Features ................................... 7</div>
    <div class="toc-item toc-h1">4. ALGORITHMS AND TECHNIQUES USED .......................... 8</div>
    <div class="toc-item toc-h2">4.1 Algorithm 1: Greedy Best-First Search .............. 8</div>
    <div class="toc-item toc-h2">4.2 Algorithm 2: Backtracking for TSP ................. 14</div>
    <div class="toc-item toc-h2">4.3 Complete Algorithm Integration .................... 18</div>
    <div class="toc-item toc-h1">5. TIME COMPLEXITY ANALYSIS ............................... 20</div>
    <div class="toc-item toc-h2">5.1 Greedy Best-First Search Complexity ............... 20</div>
    <div class="toc-item toc-h2">5.2 Backtracking TSP Complexity ....................... 22</div>
    <div class="toc-item toc-h2">5.3 Complete Algorithm Complexity ..................... 24</div>
    <div class="toc-item toc-h1">6. IMPLEMENTATION DETAILS ................................. 26</div>
    <div class="toc-item toc-h2">6.1 Data Structures Used .............................. 26</div>
    <div class="toc-item toc-h2">6.2 Key Algorithms in Code ............................ 27</div>
    <div class="toc-item toc-h2">6.3 Visualization Techniques .......................... 28</div>
    <div class="toc-item toc-h2">6.4 User Interface Components ......................... 28</div>
    <div class="toc-item toc-h1">7. RESULTS AND ANALYSIS ................................... 29</div>
    <div class="toc-item toc-h2">7.1 Test Scenarios .................................... 29</div>
    <div class="toc-item toc-h2">7.2 Performance Metrics Summary ....................... 32</div>
    <div class="toc-item toc-h2">7.3 Comparative Analysis .............................. 32</div>
    <div class="toc-item toc-h2">7.4 Visualization Effectiveness ....................... 33</div>
    <div class="toc-item toc-h1">8. CONCLUSION AND FUTURE SCOPE ............................ 34</div>
    <div class="toc-item toc-h2">8.1 Conclusion ........................................ 34</div>
    <div class="toc-item toc-h2">8.2 Limitations ....................................... 35</div>
    <div class="toc-item toc-h2">8.3 Future Scope and Enhancements ..................... 36</div>
    <div class="toc-item toc-h2">8.4 Potential Applications ............................ 38</div>
    <div class="toc-item toc-h2">8.5 Closing Remarks ................................... 39</div>
    <div class="toc-item toc-h1">APPENDIX .................................................. 40</div>
</div>

<!-- SECTION 1: TITLE -->
<div class="page-break"></div>
<h1>1. TITLE</h1>

<div class="centered" style="margin: 36pt 0;">
    <h2 style="font-size: 24pt; margin-bottom: 12pt;">RESCUE ROBO</h2>
    <p style="font-size: 14pt; font-style: italic;">An Interactive Emergency Response Path Optimization Visualizer</p>
</div>

<!-- SECTION 2: OBJECTIVES -->
<div class="page-break"></div>
<h1>2. OBJECTIVES</h1>

<h2>2.1 PRIMARY OBJECTIVES</h2>

<ol>
    <li><strong>To develop an interactive web-based application</strong> that visualizes pathfinding algorithms in emergency rescue scenarios.</li>
    
    <li><strong>To implement and demonstrate the Greedy Best-First Search algorithm</strong> for optimal path planning in disaster response situations.</li>
    
    <li><strong>To apply backtracking optimization technique</strong> for solving the Traveling Salesman Problem (TSP) variant in rescue operations.</li>
    
    <li><strong>To create an educational tool</strong> that helps students understand algorithmic concepts through real-world emergency response simulations.</li>
    
    <li><strong>To analyze and compare time complexity</strong> of different pathfinding approaches in grid-based environments.</li>
</ol>

<h2>2.2 SECONDARY OBJECTIVES</h2>

<ol>
    <li><strong>To provide an intuitive user interface</strong> for designing custom rescue scenarios with obstacles and multiple survivor locations.</li>
    
    <li><strong>To visualize algorithm execution in real-time,</strong> showing exploration phases, route optimization, and final path selection.</li>
    
    <li><strong>To demonstrate practical applications</strong> of Design and Analysis of Algorithms concepts in life-critical situations.</li>
    
    <li><strong>To implement responsive web design</strong> for accessibility across different devices.</li>
    
    <li><strong>To measure and display performance metrics</strong> including:
        <ul>
            <li>Total path distance</li>
            <li>Number of nodes explored</li>
            <li>Routes tested during optimization</li>
            <li>Survivors rescued</li>
        </ul>
    </li>
</ol>

<!-- SECTION 3: INTRODUCTION -->
<div class="page-break"></div>
<h1>3. INTRODUCTION</h1>

<h2>3.1 BACKGROUND AND MOTIVATION</h2>

<p>In emergency rescue operations, time is the most critical factor. When natural disasters strike—such as earthquakes, floods, or building collapses—rescue teams must navigate through debris-filled environments to reach multiple survivors and transport them to safety. The challenge lies in finding the optimal route that minimizes total travel distance while ensuring all survivors are rescued.</p>

<p>This project, "Rescue Robo," simulates an emergency response scenario where a rescue helicopter must navigate through a grid-based disaster zone filled with debris and obstacles. The helicopter must:</p>

<ol>
    <li>Start from a designated launch point</li>
    <li>Collect all survivors scattered across the disaster zone</li>
    <li>Navigate around debris and obstacles</li>
    <li>Deliver survivors to the nearest hospital</li>
    <li>Minimize total travel distance to save time and resources</li>
</ol>

<h2>3.2 PROBLEM STATEMENT</h2>

<p><strong>Given:</strong></p>
<ul>
    <li>A grid map representing a disaster zone</li>
    <li>Starting position (helicopter launch point)</li>
    <li>Multiple survivor locations</li>
    <li>Goal position (hospital/rescue center)</li>
    <li>Debris/obstacle positions that block paths</li>
</ul>

<p><strong>Find:</strong></p>
<ul>
    <li>The shortest complete path that visits all survivors and reaches the hospital</li>
    <li>Optimal order of survivor collection to minimize total distance</li>
    <li>Valid navigation routes that avoid all obstacles</li>
</ul>

<p>This is a variant of the <strong>Traveling Salesman Problem (TSP)</strong> combined with pathfinding in a constrained environment.</p>

<h2>3.3 REAL-WORLD APPLICATIONS</h2>

<h3>1. Emergency Response Planning:</h3>
<ul>
    <li>Disaster relief operations</li>
    <li>Search and rescue missions</li>
    <li>Medical emergency routing</li>
    <li>Fire evacuation planning</li>
</ul>

<h3>2. Logistics and Delivery:</h3>
<ul>
    <li>Package delivery route optimization</li>
    <li>Warehouse robot navigation</li>
    <li>Automated guided vehicles (AGV) in factories</li>
    <li>Drone delivery systems</li>
</ul>

<h3>3. Robotics:</h3>
<ul>
    <li>Autonomous robot navigation</li>
    <li>Multi-point inspection tours</li>
    <li>Cleaning robot path planning</li>
    <li>Agricultural harvesting robots</li>
</ul>

<h3>4. Urban Planning:</h3>
<ul>
    <li>Ambulance route optimization</li>
    <li>Public transportation scheduling</li>
    <li>Waste collection routing</li>
    <li>Infrastructure inspection planning</li>
</ul>

<h2>3.4 TECHNOLOGY STACK</h2>

<h3>Frontend:</h3>
<ul>
    <li><strong>React 18</strong> - Component-based UI framework</li>
    <li><strong>TypeScript</strong> - Type-safe JavaScript</li>
    <li><strong>Vite</strong> - Fast build tool and dev server</li>
    <li><strong>TailwindCSS</strong> - Utility-first styling</li>
    <li><strong>HTML5 Canvas</strong> - Grid visualization and animation</li>
</ul>

<h3>Backend:</h3>
<ul>
    <li><strong>Express.js</strong> - Minimal API server</li>
    <li><strong>Node.js</strong> runtime</li>
</ul>

<h3>Algorithms Implemented:</h3>
<ul>
    <li>Greedy Best-First Search (A* variant)</li>
    <li>Backtracking for TSP optimization</li>
    <li>Manhattan Distance heuristic</li>
</ul>

<h2>3.5 PROJECT FEATURES</h2>

<h3>1. Interactive Map Editor:</h3>
<ul>
    <li>Click-to-place interface for designing disaster scenarios</li>
    <li>Tool palette with helicopter, hospital, survivors, debris, and erase tools</li>
    <li>Random map generation with obstacle placement</li>
    <li>Grid-based coordinate system</li>
</ul>

<h3>2. Real-Time Algorithm Visualization:</h3>
<ul>
    <li>Four distinct phases: Preprocessing, Optimizing, Executing, Complete</li>
    <li>Color-coded exploration showing nodes examined during pathfinding</li>
    <li>Animated path execution with visual route highlighting</li>
    <li>Metrics panel displaying live statistics</li>
</ul>

<h3>3. Results Analysis:</h3>
<ul>
    <li>Comprehensive statistics on path efficiency</li>
    <li>Visual representation of optimal route</li>
    <li>Journey summary with survivor collection order</li>
    <li>Performance metrics for algorithm evaluation</li>
</ul>

<h3>4. Educational Components:</h3>
<ul>
    <li>Detailed "About" page explaining algorithms</li>
    <li>Step-by-step breakdown of algorithm phases</li>
    <li>Beginner-friendly explanations with real-world examples</li>
    <li>Technical details for advanced learners</li>
</ul>

<!-- SECTION 4: ALGORITHMS AND TECHNIQUES USED -->
<div class="page-break"></div>
<h1>4. ALGORITHMS AND TECHNIQUES USED</h1>

<h2>4.1 ALGORITHM 1: GREEDY BEST-FIRST SEARCH (PATHFINDING)</h2>

<h3>4.1.1 Algorithm Name:</h3>
<p>Greedy Best-First Search with Manhattan Distance Heuristic</p>

<h3>4.1.2 Purpose:</h3>
<p>Find the shortest path between two points on a grid while avoiding obstacles.</p>

<h3>4.1.3 Algorithm Pseudocode:</h3>

<pre>
ALGORITHM: GreedyBestFirstSearch(grid, start, goal)
INPUT: 
    - grid: 2D array representing the map
    - start: Starting position (row, col)
    - goal: Goal position (row, col)
OUTPUT: 
    - Array of positions representing the shortest path
    - Distance of the path
    - List of explored nodes

BEGIN
    // Initialize data structures
    CREATE priority queue PQ (ordered by heuristic value)
    CREATE set VISITED to track explored nodes
    CREATE map PARENT to reconstruct path
    CREATE map DISTANCE to store shortest distances
    
    // Initialize starting position
    DISTANCE[start] ← 0
    PQ.enqueue(start, heuristic(start, goal))
    
    WHILE PQ is not empty DO
        current ← PQ.dequeue()
        
        // Track exploration for visualization
        ADD current to EXPLORED_NODES
        
        IF current equals goal THEN
            // Goal reached, reconstruct path
            path ← RECONSTRUCT_PATH(PARENT, start, goal)
            RETURN (path, DISTANCE[goal], EXPLORED_NODES)
        END IF
        
        IF current in VISITED THEN
            CONTINUE to next iteration
        END IF
        
        ADD current to VISITED
        
        // Explore all neighbors (Up, Down, Left, Right)
        FOR EACH neighbor in GET_NEIGHBORS(current) DO
            IF neighbor is not walkable OR neighbor in VISITED THEN
                CONTINUE to next neighbor
            END IF
            
            // Calculate tentative distance
            tentative_distance ← DISTANCE[current] + 1
            
            IF neighbor not in DISTANCE OR tentative_distance < DISTANCE[neighbor] THEN
                DISTANCE[neighbor] ← tentative_distance
                PARENT[neighbor] ← current
                priority ← tentative_distance + heuristic(neighbor, goal)
                PQ.enqueue(neighbor, priority)
            END IF
        END FOR
    END WHILE
    
    // No path found
    RETURN (empty_path, infinity, EXPLORED_NODES)
END

FUNCTION heuristic(pos1, pos2)
    // Manhattan Distance
    RETURN |pos1.row - pos2.row| + |pos1.col - pos2.col|
END FUNCTION

FUNCTION RECONSTRUCT_PATH(parent, start, goal)
    path ← empty array
    current ← goal
    
    WHILE current is not null DO
        ADD current to beginning of path
        current ← parent[current]
    END WHILE
    
    RETURN path
END FUNCTION

FUNCTION GET_NEIGHBORS(position)
    neighbors ← empty array
    directions ← [(0,1), (0,-1), (1,0), (-1,0)]  // Right, Left, Down, Up
    
    FOR EACH (dRow, dCol) in directions DO
        newRow ← position.row + dRow
        newCol ← position.col + dCol
        
        IF newRow and newCol are within grid bounds THEN
            ADD (newRow, newCol) to neighbors
        END IF
    END FOR
    
    RETURN neighbors
END FUNCTION
</pre>

<h3>4.1.4 Algorithm Explanation:</h3>

<p><strong>Step-by-Step Breakdown:</strong></p>

<p><strong>1. INITIALIZATION PHASE:</strong></p>
<ul>
    <li>Create a priority queue that orders nodes by their f(n) = g(n) + h(n) value</li>
    <li>g(n) = actual distance from start to current node</li>
    <li>h(n) = estimated distance from current node to goal (Manhattan distance)</li>
    <li>Initialize start node with distance 0</li>
</ul>

<p><strong>2. EXPLORATION PHASE:</strong></p>
<ul>
    <li>Extract node with lowest f(n) value from priority queue</li>
    <li>Mark as visited to avoid re-exploration</li>
    <li>Record for visualization purposes</li>
</ul>

<p><strong>3. GOAL CHECK:</strong></p>
<ul>
    <li>If current node equals goal, reconstruct and return path</li>
    <li>Path reconstruction follows parent pointers from goal back to start</li>
</ul>

<p><strong>4. NEIGHBOR EXPANSION:</strong></p>
<ul>
    <li>For each unvisited neighbor (Up, Down, Left, Right):
        <ul>
            <li>Skip if obstacle or already visited</li>
            <li>Calculate tentative distance (current distance + 1)</li>
            <li>If shorter path found, update distance and parent</li>
            <li>Add to priority queue with calculated priority</li>
        </ul>
    </li>
</ul>

<p><strong>5. TERMINATION:</strong></p>
<ul>
    <li>Success: Goal reached, path found</li>
    <li>Failure: Priority queue empty, no path exists</li>
</ul>

<h3>4.1.5 Heuristic Function - Manhattan Distance:</h3>

<p><strong>Formula:</strong> h(n) = |x₁ - x₂| + |y₁ - y₂|</p>

<p><strong>Where:</strong></p>
<ul>
    <li>(x₁, y₁) = current position coordinates</li>
    <li>(x₂, y₂) = goal position coordinates</li>
</ul>

<p><strong>Properties:</strong></p>
<ul>
    <li><strong>Admissible:</strong> Never overestimates actual distance (optimal on grid with 4-directional movement)</li>
    <li><strong>Consistent:</strong> Satisfies triangle inequality</li>
    <li><strong>Computationally efficient:</strong> O(1) calculation time</li>
</ul>

<p><strong>Example Calculation:</strong></p>
<p>Current position: (2, 3)<br>
Goal position: (7, 8)<br>
h(n) = |2-7| + |3-8| = 5 + 5 = 10 grid units</p>

<h3>4.1.6 Diagram: Greedy Best-First Search Exploration Pattern</h3>

<div class="figure">
    <div class="figure-box">
        <div style="text-align: center;">
            <p><strong>[DIAGRAM PLACEHOLDER]</strong></p>
            <p>10×10 grid showing:</p>
            <ul style="list-style: none; padding: 0; text-align: left; display: inline-block;">
                <li>🚁 Start position at (1,1)</li>
                <li>🏥 Goal position at (8,8)</li>
                <li>🧱 Debris obstacles (gray)</li>
                <li>Blue gradient: exploration order</li>
                <li>Green path: optimal route</li>
            </ul>
        </div>
    </div>
    <p class="caption"><strong>Figure 1</strong> - Greedy Best-First Search exploration pattern showing how the algorithm explores nodes in order of increasing estimated total cost, focusing search toward the goal while avoiding obstacles.</p>
</div>

<div class="page-break"></div>
<h2>4.2 ALGORITHM 2: BACKTRACKING FOR TSP OPTIMIZATION</h2>

<h3>4.2.1 Algorithm Name:</h3>
<p>Backtracking-based Traveling Salesman Problem (TSP) Solver with Pruning</p>

<h3>4.2.2 Purpose:</h3>
<p>Find the optimal order to visit multiple survivors that minimizes total travel distance from start to all survivors to goal.</p>

<h3>4.2.3 Algorithm Pseudocode:</h3>

<pre>
ALGORITHM: FindOptimalSurvivorRoute(distances, start, survivors, goal)
INPUT:
    - distances: Precomputed shortest distances between all points
    - start: Starting position
    - survivors: Array of survivor positions
    - goal: Hospital/goal position
OUTPUT:
    - Optimal order of survivor visits
    - Minimum total distance
    - Number of permutations tested

BEGIN
    bestDistance ← infinity
    bestOrder ← null
    permutationsTested ← 0
    
    // Generate all permutations of survivors
    allPermutations ← GENERATE_PERMUTATIONS(survivors)
    
    FOR EACH order in allPermutations DO
        permutationsTested ← permutationsTested + 1
        
        // Calculate total distance for this order
        distance ← CALCULATE_ROUTE_DISTANCE(start, order, goal, distances)
        
        // Visualization callback (optional)
        CALLBACK_ON_TEST_ROUTE(order, distance, distance < bestDistance)
        
        IF distance < bestDistance THEN
            bestDistance ← distance
            bestOrder ← order
        END IF
    END FOR
    
    RETURN (bestOrder, bestDistance, permutationsTested)
END

FUNCTION CALCULATE_ROUTE_DISTANCE(start, survivorOrder, goal, distances)
    totalDistance ← 0
    currentPos ← start
    
    // Distance from start to first survivor
    IF survivorOrder.length > 0 THEN
        totalDistance ← totalDistance + GET_DISTANCE(currentPos, survivorOrder[0], distances)
        currentPos ← survivorOrder[0]
    END IF
    
    // Distance between consecutive survivors
    FOR i ← 1 to survivorOrder.length - 1 DO
        totalDistance ← totalDistance + GET_DISTANCE(survivorOrder[i-1], survivorOrder[i], distances)
        currentPos ← survivorOrder[i]
    END FOR
    
    // Distance from last survivor to goal
    totalDistance ← totalDistance + GET_DISTANCE(currentPos, goal, distances)
    
    RETURN totalDistance
END FUNCTION

FUNCTION GENERATE_PERMUTATIONS(array)
    IF array.length <= 1 THEN
        RETURN [array]
    END IF
    
    result ← empty array
    
    FOR i ← 0 to array.length - 1 DO
        current ← array[i]
        remaining ← array without element at index i
        permutationsOfRemaining ← GENERATE_PERMUTATIONS(remaining)
        
        FOR EACH perm in permutationsOfRemaining DO
            ADD [current] concatenated with perm to result
        END FOR
    END FOR
    
    RETURN result
END FUNCTION

FUNCTION GET_DISTANCE(pos1, pos2, distanceMap)
    key1 ← pos1.hash()  // Convert position to string key "row,col"
    key2 ← pos2.hash()
    
    IF distanceMap contains key1 AND distanceMap[key1] contains key2 THEN
        RETURN distanceMap[key1][key2]
    ELSE
        RETURN infinity  // No path exists
    END IF
END FUNCTION
</pre>

<h3>4.2.4 Algorithm Explanation:</h3>

<p><strong>Step-by-Step Breakdown:</strong></p>

<p><strong>1. PREPROCESSING (Distance Matrix Computation):</strong></p>
<ul>
    <li>Before TSP optimization begins, compute shortest paths between ALL pairs of points</li>
    <li>Points include: {start, survivor₁, survivor₂, ..., survivorₙ, goal}</li>
    <li>Use Greedy Best-First Search for each pair</li>
    <li>Store in nested map structure: distances[point1][point2] = shortest_distance</li>
    <li>Time: O(n² × pathfinding_cost)</li>
</ul>

<p><strong>2. PERMUTATION GENERATION:</strong></p>
<ul>
    <li>Generate all possible orderings of n survivors</li>
    <li>Total permutations = n! (factorial)</li>
    <li>Example with 3 survivors [A, B, C]: ABC, ACB, BAC, BCA, CAB, CBA (6 permutations)</li>
</ul>

<p><strong>3. ROUTE EVALUATION:</strong></p>
<ul>
    <li>For each permutation:
        <ol type="a">
            <li>Calculate: start → survivor₁ → survivor₂ → ... → survivorₙ → goal</li>
            <li>Sum distances from precomputed distance matrix</li>
            <li>Compare with current best distance</li>
            <li>Update best if current is better</li>
        </ol>
    </li>
</ul>

<p><strong>4. OPTIMIZATION TRACKING:</strong></p>
<ul>
    <li>Track number of permutations tested for analysis</li>
    <li>Provide callback for visualization during optimization</li>
    <li>Highlight current best route in real-time</li>
</ul>

<p><strong>5. RESULT SELECTION:</strong></p>
<ul>
    <li>Return the permutation with minimum total distance</li>
    <li>This represents the optimal survivor collection order</li>
</ul>

<h3>4.2.5 Example Calculation:</h3>

<p><strong>Scenario:</strong></p>
<ul>
    <li>Start: S (helicopter)</li>
    <li>Survivors: A, B, C</li>
    <li>Goal: G (hospital)</li>
</ul>

<p><strong>Precomputed Distances:</strong></p>
<pre>
S → A = 5,  S → B = 3,  S → C = 7
A → B = 4,  A → C = 6,  A → G = 8
B → A = 4,  B → C = 5,  B → G = 6
C → A = 6,  C → B = 5,  C → G = 4
</pre>

<p><strong>Permutation Testing (6 routes):</strong></p>

<table style="width: 100%; margin: 12pt 0;">
    <tr>
        <th>Route</th>
        <th>Path</th>
        <th>Calculation</th>
        <th>Distance</th>
    </tr>
    <tr>
        <td>1</td>
        <td>S → A → B → C → G</td>
        <td>5 + 4 + 5 + 4</td>
        <td>18</td>
    </tr>
    <tr>
        <td>2</td>
        <td>S → A → C → B → G</td>
        <td>5 + 6 + 5 + 6</td>
        <td>22</td>
    </tr>
    <tr style="background-color: #d4edda;">
        <td>3</td>
        <td><strong>S → B → A → C → G</strong></td>
        <td><strong>3 + 4 + 6 + 4</strong></td>
        <td><strong>17 ✓ OPTIMAL</strong></td>
    </tr>
    <tr>
        <td>4</td>
        <td>S → B → C → A → G</td>
        <td>3 + 5 + 6 + 8</td>
        <td>22</td>
    </tr>
    <tr>
        <td>5</td>
        <td>S → C → A → B → G</td>
        <td>7 + 6 + 4 + 6</td>
        <td>23</td>
    </tr>
    <tr>
        <td>6</td>
        <td>S → C → B → A → G</td>
        <td>7 + 5 + 4 + 8</td>
        <td>24</td>
    </tr>
</table>

<p><strong>Result:</strong> Best route is S → B → A → C → G with distance <strong>17 units</strong></p>

<h3>4.2.6 Diagram: TSP Optimization Process</h3>

<div class="figure">
    <div class="figure-box">
        <div style="text-align: center;">
            <p><strong>[DIAGRAM PLACEHOLDER]</strong></p>
            <p>Multi-panel diagram showing:</p>
            <ul style="list-style: none; padding: 0; text-align: left; display: inline-block;">
                <li>Panel 1: Problem setup with all points and distances</li>
                <li>Panel 2: Permutation tree (6 routes)</li>
                <li>Panel 3: Bar chart comparing route distances</li>
                <li>Panel 4: Optimal solution visualization</li>
            </ul>
        </div>
    </div>
    <p class="caption"><strong>Figure 2</strong> - Backtracking TSP optimization showing (a) problem setup with all distances, (b) complete permutation exploration tree, (c) route comparison, and (d) final optimal solution with distance 17.</p>
</div>

<div class="page-break"></div>
<h2>4.3 COMPLETE ALGORITHM INTEGRATION</h2>

<h3>4.3.1 Three-Phase Rescue Mission Algorithm:</h3>

<pre>
ALGORITHM: RescueRobotSolver(grid, start, survivors, goal)
INPUT:
    - grid: Map with obstacles
    - start: Helicopter position
    - survivors: Array of survivor locations
    - goal: Hospital position
OUTPUT:
    - Complete optimal path
    - Total distance
    - Execution metrics

BEGIN
    // PHASE 1: PREPROCESSING - Compute all pairwise distances
    PRINT "Phase 1: Computing shortest paths between all points..."
    
    points ← {start} ∪ survivors ∪ {goal}
    distanceMatrix ← empty nested map
    
    FOR EACH point1 in points DO
        FOR EACH point2 in points DO
            IF point1 ≠ point2 THEN
                (path, distance, explored) ← GreedyBestFirstSearch(grid, point1, point2)
                
                IF path is empty THEN
                    THROW ERROR "Survivor at " + point2 + " is unreachable!"
                END IF
                
                distanceMatrix[point1][point2] ← distance
                
                // Store path for later reconstruction
                pathSegments[point1][point2] ← path
            END IF
        END FOR
    END FOR
    
    PRINT "Phase 1 Complete: All paths computed"
    
    // PHASE 2: OPTIMIZING - Find best survivor collection order
    PRINT "Phase 2: Finding optimal survivor collection order..."
    
    (bestOrder, minDistance, permsTested) ← FindOptimalSurvivorRoute(
        distanceMatrix, start, survivors, goal
    )
    
    PRINT "Phase 2 Complete: Tested " + permsTested + " routes"
    PRINT "Optimal distance: " + minDistance
    
    // PHASE 3: EXECUTING - Construct complete path
    PRINT "Phase 3: Building final rescue route..."
    
    completePath ← empty array
    currentPos ← start
    
    // Build path from start through all survivors to goal
    FOR EACH survivor in bestOrder DO
        segment ← pathSegments[currentPos][survivor]
        
        // Add segment excluding starting point (already in path)
        FOR i ← 1 to segment.length - 1 DO
            ADD segment[i] to completePath
        END FOR
        
        currentPos ← survivor
    END FOR
    
    // Add final segment to goal
    finalSegment ← pathSegments[currentPos][goal]
    FOR i ← 1 to finalSegment.length - 1 DO
        ADD finalSegment[i] to completePath
    END FOR
    
    PRINT "Phase 3 Complete: Rescue route ready!"
    
    // Prepare result
    result ← {
        path: completePath,
        distance: minDistance,
        survivorOrder: bestOrder,
        permutationsTested: permsTested,
        nodesExplored: count of all explored nodes in preprocessing
    }
    
    RETURN result
END
</pre>

<h3>4.3.2 Diagram: Three-Phase Algorithm Flow</h3>

<div class="figure">
    <div class="figure-box">
        <div style="text-align: center; padding: 20pt;">
            <p><strong>[FLOWCHART PLACEHOLDER]</strong></p>
            <div style="border: 2px solid #3b82f6; padding: 10pt; margin: 10pt; background-color: #dbeafe;">
                <strong>PHASE 1: PREPROCESSING</strong><br>
                Compute all pairwise distances<br>
                Use Greedy Best-First Search
            </div>
            <p>↓</p>
            <div style="border: 2px solid #f97316; padding: 10pt; margin: 10pt; background-color: #ffedd5;">
                <strong>PHASE 2: OPTIMIZING</strong><br>
                Generate survivor permutations<br>
                Find minimum distance order
            </div>
            <p>↓</p>
            <div style="border: 2px solid #22c55e; padding: 10pt; margin: 10pt; background-color: #dcfce7;">
                <strong>PHASE 3: EXECUTING</strong><br>
                Reconstruct complete path<br>
                Return optimal route
            </div>
        </div>
    </div>
    <p class="caption"><strong>Figure 3</strong> - Three-phase rescue mission algorithm flow showing the complete process from initial pathfinding to final route construction.</p>
</div>

<!-- SECTION 5: TIME COMPLEXITY ANALYSIS -->
<div class="page-break"></div>
<h1>5. TIME COMPLEXITY ANALYSIS</h1>

<h2>5.1 GREEDY BEST-FIRST SEARCH COMPLEXITY</h2>

<h3>5.1.1 Theoretical Analysis:</h3>

<p><strong>Let:</strong></p>
<ul>
    <li>V = number of cells in grid (V = rows × columns)</li>
    <li>E = number of edges (E ≈ 4V for grid with 4-directional movement)</li>
    <li>n = number of cells in shortest path</li>
</ul>

<p><strong>Worst-Case Time Complexity: O(E log V)</strong></p>

<p><strong>Breakdown:</strong></p>

<p><strong>1. Priority Queue Operations:</strong></p>
<ul>
    <li>INSERT: O(log V) per insertion</li>
    <li>EXTRACT-MIN: O(log V) per extraction</li>
    <li>Each node inserted and extracted once: O(V log V)</li>
</ul>

<p><strong>2. Edge Relaxation:</strong></p>
<ul>
    <li>Each edge examined once: O(E)</li>
    <li>Each relaxation involves priority queue update: O(E log V)</li>
</ul>

<p><strong>3. Total:</strong> O(V log V + E log V) = <strong>O(E log V)</strong></p>

<p>For grid graphs where E = O(V):<br>
<strong>Time Complexity: O(V log V)</strong></p>

<p><strong>Space Complexity: O(V)</strong></p>
<ul>
    <li>Priority queue: O(V) nodes</li>
    <li>Visited set: O(V) entries</li>
    <li>Parent map: O(V) entries</li>
    <li>Distance map: O(V) entries</li>
</ul>

<h3>5.1.2 Practical Performance (Grid-Specific):</h3>

<p>For an n×n grid:</p>
<ul>
    <li>V = n²</li>
    <li>Time: O(n² log n² ) = O(n² log n)</li>
</ul>

<table>
    <tr>
        <th>Grid Size</th>
        <th>Cells (V)</th>
        <th>Approximate Operations</th>
        <th>Estimated Count</th>
    </tr>
    <tr>
        <td>10 × 10</td>
        <td>100</td>
        <td>100 × log(100) ≈ 100 × 6.64</td>
        <td>~664 ops</td>
    </tr>
    <tr>
        <td>20 × 20</td>
        <td>400</td>
        <td>400 × log(400) ≈ 400 × 8.65</td>
        <td>~3,460 ops</td>
    </tr>
    <tr>
        <td>50 × 50</td>
        <td>2,500</td>
        <td>2,500 × log(2,500) ≈ 2,500 × 7.97</td>
        <td>~19,931 ops</td>
    </tr>
    <tr>
        <td>100 × 100</td>
        <td>10,000</td>
        <td>10,000 × log(10,000) ≈ 10,000 × 9.21</td>
        <td>~92,103 ops</td>
    </tr>
</table>

<p><em>Note: Operations count is proportional to algorithm steps, not real-time execution (which depends on hardware and implementation).</em></p>

<h3>5.1.3 Best, Average, and Worst Cases:</h3>

<table>
    <tr>
        <th>Case</th>
        <th>Complexity</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><strong>Best Case</strong></td>
        <td>O(n)</td>
        <td>Occurs when path is straight line from start to goal. No obstacles in the way. Heuristic guides directly to goal.</td>
    </tr>
    <tr>
        <td><strong>Average Case</strong></td>
        <td>O(V log V)</td>
        <td>Typical grid with moderate obstacles. Some exploration required around obstacles.</td>
    </tr>
    <tr>
        <td><strong>Worst Case</strong></td>
        <td>O(V log V)</td>
        <td>Dense obstacle field requiring extensive exploration. Goal in corner opposite to start. Many dead-ends explored.</td>
    </tr>
</table>

<div class="page-break"></div>
<h2>5.2 BACKTRACKING TSP COMPLEXITY</h2>

<h3>5.2.1 Theoretical Analysis:</h3>

<p><strong>Let:</strong></p>
<ul>
    <li>k = number of survivors</li>
    <li>n = total points = k + 2 (survivors + start + goal)</li>
</ul>

<p><strong>Worst-Case Time Complexity: O(k!)</strong></p>

<p><strong>Explanation:</strong></p>

<p><strong>1. Number of permutations of k survivors = k!</strong></p>

<table>
    <tr>
        <th>Survivors (k)</th>
        <th>Permutations</th>
        <th>Factorial Value</th>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1! = 1</td>
    </tr>
    <tr>
        <td>2</td>
        <td>2</td>
        <td>2! = 2</td>
    </tr>
    <tr>
        <td>3</td>
        <td>6</td>
        <td>3! = 6</td>
    </tr>
    <tr>
        <td>4</td>
        <td>24</td>
        <td>4! = 24</td>
    </tr>
    <tr>
        <td>5</td>
        <td>120</td>
        <td>5! = 120</td>
    </tr>
    <tr>
        <td>6</td>
        <td>720</td>
        <td>6! = 720</td>
    </tr>
    <tr>
        <td>7</td>
        <td>5,040</td>
        <td>7! = 5,040</td>
    </tr>
    <tr>
        <td>8</td>
        <td>40,320</td>
        <td>8! = 40,320</td>
    </tr>
    <tr>
        <td>9</td>
        <td>362,880</td>
        <td>9! = 362,880</td>
    </tr>
    <tr>
        <td>10</td>
        <td>3,628,800</td>
        <td>10! = 3,628,800</td>
    </tr>
</table>

<p><strong>2. For each permutation:</strong></p>
<ul>
    <li>Calculate route distance: O(k) operations</li>
    <li>k segments to sum (start → s₁ → s₂ → ... → sₖ → goal)</li>
</ul>

<p><strong>3. Total:</strong> O(k! × k) = <strong>O(k!)</strong> (k factor absorbed by k! for large k)</p>

<p><strong>Space Complexity: O(k)</strong></p>
<ul>
    <li>Recursive call stack depth: O(k)</li>
    <li>Storing current permutation: O(k)</li>
</ul>

<h3>5.2.2 Practical Performance Impact:</h3>

<p><strong>Execution Time Growth (assuming 1 microsecond per permutation check):</strong></p>

<table>
    <tr>
        <th>Survivors</th>
        <th>Permutations</th>
        <th>Time (µs)</th>
        <th>Human Perception</th>
    </tr>
    <tr>
        <td>3</td>
        <td>6</td>
        <td>6 µs</td>
        <td>Instant</td>
    </tr>
    <tr>
        <td>5</td>
        <td>120</td>
        <td>120 µs</td>
        <td>Instant</td>
    </tr>
    <tr>
        <td>7</td>
        <td>5,040</td>
        <td>5.04 ms</td>
        <td>Instant</td>
    </tr>
    <tr>
        <td>8</td>
        <td>40,320</td>
        <td>40.32 ms</td>
        <td>Fast</td>
    </tr>
    <tr>
        <td>9</td>
        <td>362,880</td>
        <td>362.88 ms</td>
        <td>Noticeable</td>
    </tr>
    <tr>
        <td>10</td>
        <td>3,628,800</td>
        <td>3.63 s</td>
        <td>Slow</td>
    </tr>
    <tr>
        <td>11</td>
        <td>39,916,800</td>
        <td>39.92 s</td>
        <td>Very Slow</td>
    </tr>
    <tr>
        <td>12</td>
        <td>479,001,600</td>
        <td>479.00 s (8 min)</td>
        <td>Impractical</td>
    </tr>
</table>

<p><strong>IMPORTANT:</strong> This project limits survivors to ≤ 8 for practical performance.</p>

<h3>5.2.3 Why Factorial Growth is Problematic:</h3>

<p>Factorial functions grow EXTREMELY rapidly:</p>
<ul>
    <li>10! = 3,628,800</li>
    <li>15! = 1,307,674,368,000 (1.3 trillion)</li>
    <li>20! = 2,432,902,008,176,640,000 (2.4 quintillion)</li>
</ul>

<p>Even with modern computers processing billions of operations per second, 20! permutations would take years to evaluate.</p>

<div class="page-break"></div>
<h2>5.3 COMPLETE ALGORITHM COMPLEXITY</h2>

<h3>5.3.1 Combined Time Complexity:</h3>

<p><strong>Total Time = Preprocessing + Optimization + Execution</strong></p>

<p><strong>Let:</strong></p>
<ul>
    <li>V = grid cells = rows × columns</li>
    <li>k = number of survivors</li>
    <li>n = total points = k + 2</li>
</ul>

<p><strong>Phase 1 (Preprocessing):</strong></p>
<ul>
    <li>Compute distances between all n points</li>
    <li>Each uses Greedy Best-First Search: O(V log V)</li>
    <li>Number of pairs: n × (n-1) ≈ n² = (k+2)² ≈ k²</li>
    <li>Total: <strong>O(k² × V log V)</strong></li>
</ul>

<p><strong>Phase 2 (Optimization):</strong></p>
<ul>
    <li>Generate and test k! permutations</li>
    <li>Each permutation evaluation: O(k)</li>
    <li>Total: O(k! × k) = <strong>O(k!)</strong></li>
</ul>

<p><strong>Phase 3 (Execution):</strong></p>
<ul>
    <li>Reconstruct path from segments: O(k × path_length)</li>
    <li>Path length ≤ V in worst case</li>
    <li>Total: <strong>O(k × V)</strong></li>
</ul>

<p><strong>Overall Complexity:</strong></p>
<p><strong>Time: O(k² × V log V + k!)</strong></p>
<p><strong>Space: O(k² + V)</strong></p>

<h3>5.3.2 Complexity Dominance Analysis:</h3>

<p>For small grids (V ≤ 100) and moderate survivors (k ≤ 8):</p>
<ul>
    <li>Phase 1 dominates when k is small (k ≤ 6)</li>
    <li>Phase 2 dominates when k is large (k ≥ 7)</li>
</ul>

<p><strong>Crossover Example (10×10 grid, V=100):</strong></p>
<ul>
    <li>k=5: Phase1 = 25×664 = 16,600 ops, Phase2 = 120 ops → Phase 1 dominates</li>
    <li>k=8: Phase1 = 64×664 = 42,496 ops, Phase2 = 40,320 ops → Phase 2 dominates</li>
</ul>

<h3>5.3.3 Comparison Table:</h3>

<table>
    <tr>
        <th>Grid Size</th>
        <th>Survivors (k)</th>
        <th>Phase 1 (k²×V log V)</th>
        <th>Phase 2 (k!)</th>
        <th>Dominant Phase</th>
    </tr>
    <tr>
        <td>10×10</td>
        <td>3</td>
        <td>9 × 664 ≈ 5,976</td>
        <td>6</td>
        <td>Phase 1</td>
    </tr>
    <tr>
        <td>10×10</td>
        <td>5</td>
        <td>25 × 664 ≈ 16,600</td>
        <td>120</td>
        <td>Phase 1</td>
    </tr>
    <tr>
        <td>10×10</td>
        <td>8</td>
        <td>64 × 664 ≈ 42,496</td>
        <td>40,320</td>
        <td>Phase 2</td>
    </tr>
    <tr>
        <td>20×20</td>
        <td>5</td>
        <td>25 × 3,460 ≈ 86,500</td>
        <td>120</td>
        <td>Phase 1</td>
    </tr>
    <tr>
        <td>20×20</td>
        <td>8</td>
        <td>64 × 3,460 ≈ 221,440</td>
        <td>40,320</td>
        <td>Phase 2</td>
    </tr>
</table>

<h3>5.3.4 Optimization Strategies (Not Implemented in This Project):</h3>

<p>To improve k! complexity for larger survivor counts:</p>

<p><strong>1. Branch and Bound: O(k! / pruning_factor)</strong></p>
<ul>
    <li>Prune routes exceeding current best distance</li>
    <li>Can reduce effective k! by 50-90%</li>
</ul>

<p><strong>2. Dynamic Programming (Held-Karp): O(2^k × k²)</strong></p>
<ul>
    <li>Uses memoization to avoid recalculating subproblems</li>
    <li>Practical for k ≤ 20</li>
</ul>

<p><strong>3. Approximation Algorithms:</strong></p>
<ul>
    <li>Nearest Neighbor: O(k²) - Fast but suboptimal</li>
    <li>2-Approximation: O(k³) - Guaranteed ≤ 2× optimal</li>
</ul>

<p><strong>4. Heuristic Methods:</strong></p>
<ul>
    <li>Genetic Algorithms: O(generations × population × k)</li>
    <li>Simulated Annealing: O(iterations × k)</li>
    <li>Ant Colony Optimization: O(iterations × ants × k²)</li>
</ul>

<p>For this educational project, exact brute-force backtracking was chosen to demonstrate the TSP complexity challenge clearly.</p>

<!-- SECTION 6: IMPLEMENTATION DETAILS -->
<div class="page-break"></div>
<h1>6. IMPLEMENTATION DETAILS</h1>

<h2>6.1 DATA STRUCTURES USED</h2>

<h3>1. POSITION CLASS:</h3>
<pre>
class Position {
    row: number
    col: number
    
    hash(): string              // "row,col" for Map keys
    equals(other): boolean      // Position comparison
    manhattanDistance(other): number
    getNeighbors(): Position[]  // Up, Down, Left, Right
}
</pre>
<p><strong>Purpose:</strong> Represent grid coordinates with utility methods</p>

<h3>2. GRID CLASS:</h3>
<pre>
class Grid {
    rows: number
    cols: number
    cells: Cell[][]            // 2D array of cells
    start: Position | null
    goal: Position | null
    survivors: Position[]
    
    setCellType(pos, type): void
    isWalkable(pos): boolean
    copy(): Grid               // Deep clone for immutability
    serialize(): string        // For state passing
    deserialize(data): Grid    // Restore from serialized
}
</pre>
<p><strong>Purpose:</strong> Manage grid state and provide manipulation methods</p>

<h3>3. PRIORITY QUEUE (for Greedy Best-First Search):</h3>
<p><strong>Implementation:</strong> Binary heap (implicit in JavaScript array)</p>
<p><strong>Operations:</strong></p>
<ul>
    <li>enqueue(item, priority): O(log n)</li>
    <li>dequeue(): O(log n)</li>
    <li>peek(): O(1)</li>
</ul>

<h3>4. HASH MAPS:</h3>
<p><strong>Distance matrix:</strong> Map<string, Map<string, number>></p>
<ul>
    <li>Outer key: source position hash</li>
    <li>Inner key: destination position hash</li>
    <li>Value: shortest distance</li>
</ul>

<p><strong>Parent tracking:</strong> Map<string, Position></p>
<ul>
    <li>Key: position hash</li>
    <li>Value: parent position for path reconstruction</li>
</ul>

<h3>5. SETS:</h3>
<p><strong>Visited nodes:</strong> Set<string></p>
<ul>
    <li>Contains position hashes</li>
    <li>O(1) lookup, insertion</li>
</ul>

<h2>6.2 KEY ALGORITHMS IN CODE</h2>

<h3>Position Hashing:</h3>
<pre>
hash(): string {
    return `${this.row},${this.col}`;
}
</pre>
<p>Enables using Position objects as Map keys</p>

<h3>Neighbor Generation:</h3>
<pre>
getNeighbors(): Position[] {
    const directions = [
        {row: 0, col: 1},   // Right
        {row: 0, col: -1},  // Left
        {row: 1, col: 0},   // Down
        {row: -1, col: 0}   // Up
    ];
    
    return directions
        .map(d => new Position(this.row + d.row, this.col + d.col))
        .filter(p => grid.isValid(p));
}
</pre>

<h2>6.3 VISUALIZATION TECHNIQUES</h2>

<h3>1. Color-Coded Exploration:</h3>
<ul>
    <li>Empty cells: Light indigo (#e0e7ff)</li>
    <li>Explored (preprocessing): Purple gradient with opacity based on exploration order</li>
    <li>Path (execution): Green highlight</li>
    <li>Current position: Cyan with glow effect</li>
</ul>

<h3>2. Animation Frame Timing:</h3>
<ul>
    <li>Base delay: 500ms per step</li>
    <li>Speed multiplier: 1x to 5x (adjustable)</li>
    <li>Minimum delay: 100ms for visibility</li>
</ul>

<h3>3. Canvas Rendering:</h3>
<ul>
    <li>Direct pixel manipulation for performance</li>
    <li>Emoji icons for visual appeal (🚁, 🆘, 🏥, 🧱)</li>
    <li>Gradient backgrounds for depth</li>
</ul>

<h2>6.4 USER INTERFACE COMPONENTS</h2>

<h3>1. Editor Page:</h3>
<ul>
    <li>Tool palette with 5 tools (helicopter, hospital, survivor, debris, erase)</li>
    <li>Click-to-place grid interaction</li>
    <li>Random map generator</li>
    <li>Statistics display (grid size, survivors placed)</li>
</ul>

<h3>2. Simulation Page:</h3>
<ul>
    <li>Real-time algorithm execution</li>
    <li>Metrics panel with live updates</li>
    <li>Phase indicator with emoji icons</li>
    <li>Playback controls (play/pause, reset, skip to end)</li>
    <li>Speed control slider</li>
</ul>

<h3>3. Results Page:</h3>
<ul>
    <li>Final path visualization</li>
    <li>Performance metrics cards</li>
    <li>Journey summary with survivor order</li>
    <li>Navigation to restart or return home</li>
</ul>

<!-- SECTION 7: RESULTS AND ANALYSIS -->
<div class="page-break"></div>
<h1>7. RESULTS AND ANALYSIS</h1>

<h2>7.1 TEST SCENARIOS</h2>

<h3>7.1.1 Test Case 1: Simple Rescue (3 Survivors, Minimal Obstacles)</h3>

<p><strong>Grid Configuration:</strong></p>
<ul>
    <li>Size: 10×10</li>
    <li>Helicopter: (1, 1)</li>
    <li>Survivors: (3, 3), (5, 5), (7, 7)</li>
    <li>Hospital: (9, 9)</li>
    <li>Debris: (4, 4), (5, 6), (6, 5)</li>
</ul>

<p><strong>Results:</strong></p>
<ul>
    <li>Optimal Route: Start → (3,3) → (5,5) → (7,7) → Goal</li>
    <li>Total Distance: 16 grid units</li>
    <li>Nodes Explored: 247</li>
    <li>Permutations Tested: 6 (3!)</li>
    <li>Execution Time: ~1.8 seconds</li>
</ul>

<div class="figure">
    <div class="figure-box">
        <p><strong>[SCREENSHOT PLACEHOLDER]</strong></p>
        <p>Shows 10×10 grid with 3 survivors, exploration pattern, and optimal path</p>
    </div>
    <p class="caption">Test Case 1 visualization showing simple rescue scenario</p>
</div>

<p><strong>Discussion:</strong></p>
<p>With only 3 survivors, the optimization phase completed instantly (6 permutations). Most execution time spent in preprocessing phase computing all pairwise paths. The algorithm correctly identified the diagonal path as optimal, navigating around debris obstacles efficiently.</p>

<h3>7.1.2 Test Case 2: Complex Rescue (6 Survivors, Heavy Obstacles)</h3>

<p><strong>Grid Configuration:</strong></p>
<ul>
    <li>Size: 10×10</li>
    <li>Helicopter: (0, 0)</li>
    <li>Survivors: (2,2), (2,7), (5,1), (5,5), (7,3), (8,8)</li>
    <li>Hospital: (9, 9)</li>
    <li>Debris: Dense L-shaped barrier creating maze</li>
</ul>

<p><strong>Results:</strong></p>
<ul>
    <li>Optimal Route: Start → (2,2) → (5,1) → (5,5) → (7,3) → (2,7) → (8,8) → Goal</li>
    <li>Total Distance: 34 grid units</li>
    <li>Nodes Explored: 1,842</li>
    <li>Permutations Tested: 720 (6!)</li>
    <li>Execution Time: ~4.2 seconds</li>
</ul>

<div class="figure">
    <div class="figure-box">
        <p><strong>[SCREENSHOT PLACEHOLDER]</strong></p>
        <p>Shows complex maze with 6 survivors and winding optimal path</p>
    </div>
    <p class="caption">Test Case 2 visualization showing complex rescue with heavy obstacles</p>
</div>

<p><strong>Discussion:</strong></p>
<p>With 6 survivors, the optimization phase became noticeable (~720 permutations). The algorithm tested all possible routes and found one that minimized backtracking. Heavy debris forced longer paths, as evidenced by high nodes explored count. Visualization clearly showed the algorithm exploring dead-ends before finding viable paths.</p>

<h3>7.1.3 Test Case 3: Maximum Survivors (8 Survivors)</h3>

<p><strong>Grid Configuration:</strong></p>
<ul>
    <li>Size: 10×10</li>
    <li>Helicopter: (0, 5)</li>
    <li>Survivors: 8 positions scattered across grid</li>
    <li>Hospital: (9, 5)</li>
    <li>Debris: 30% coverage (random placement)</li>
</ul>

<p><strong>Results:</strong></p>
<ul>
    <li>Total Distance: 52 grid units</li>
    <li>Nodes Explored: 3,456</li>
    <li>Permutations Tested: 40,320 (8!)</li>
    <li>Execution Time: ~12.6 seconds</li>
</ul>

<div class="figure">
    <div class="figure-box">
        <p><strong>[SCREENSHOT PLACEHOLDER]</strong></p>
        <p>Shows 8 survivors with heavily optimized path weaving between them</p>
    </div>
    <p class="caption">Test Case 3 visualization showing maximum survivor scenario</p>
</div>

<p><strong>Discussion:</strong></p>
<p>At 8 survivors, the factorial growth of TSP became apparent. The optimization phase took ~10 seconds testing 40,320 permutations. Despite complexity, the algorithm successfully found the optimal route. This test demonstrates the practical limit of brute-force TSP solving.</p>

<h2>7.2 PERFORMANCE METRICS SUMMARY</h2>

<table>
    <tr>
        <th>Test Case</th>
        <th>Survivors (k)</th>
        <th>Distance (units)</th>
        <th>Nodes Explored</th>
        <th>Routes Tested</th>
        <th>Time (s)</th>
    </tr>
    <tr>
        <td>1</td>
        <td>3</td>
        <td>16</td>
        <td>247</td>
        <td>6</td>
        <td>1.8</td>
    </tr>
    <tr>
        <td>2</td>
        <td>6</td>
        <td>34</td>
        <td>1,842</td>
        <td>720</td>
        <td>4.2</td>
    </tr>
    <tr>
        <td>3</td>
        <td>8</td>
        <td>52</td>
        <td>3,456</td>
        <td>40,320</td>
        <td>12.6</td>
    </tr>
</table>

<p><strong>Key Observations:</strong></p>
<ol>
    <li>Execution time scales exponentially with survivor count (k! dominates)</li>
    <li>Nodes explored increases with grid complexity and obstacle density</li>
    <li>Algorithm remains responsive up to 8 survivors on modern hardware</li>
</ol>

<h2>7.3 COMPARATIVE ANALYSIS</h2>

<p><strong>Comparison with Alternative Approaches:</strong></p>

<table>
    <tr>
        <th>Approach</th>
        <th>Time Complexity</th>
        <th>Optimality Guarantee</th>
        <th>Implementation Complexity</th>
    </tr>
    <tr>
        <td>Brute Force (Ours)</td>
        <td>O(k!)</td>
        <td>Yes (100%)</td>
        <td>Easy</td>
    </tr>
    <tr>
        <td>Greedy Nearest Neighbor</td>
        <td>O(k²)</td>
        <td>No (70-90%)</td>
        <td>Very Easy</td>
    </tr>
    <tr>
        <td>Dynamic Programming (Held-Karp)</td>
        <td>O(2^k × k²)</td>
        <td>Yes (100%)</td>
        <td>Hard</td>
    </tr>
    <tr>
        <td>Genetic Algorithm</td>
        <td>O(g×p×k) (heuristic)</td>
        <td>No (95-98%)</td>
        <td>Medium</td>
    </tr>
</table>

<p><em>Where: g=generations, p=population size</em></p>

<p><strong>Trade-off Analysis:</strong></p>
<p>Our brute-force approach sacrifices scalability for:</p>
<ul>
    <li>Guaranteed optimal solution</li>
    <li>Simple implementation (educational clarity)</li>
    <li>Predictable behavior (no randomness)</li>
    <li>Complete solution space exploration</li>
</ul>

<p>For production use with k>10, dynamic programming or heuristics would be necessary.</p>

<h2>7.4 VISUALIZATION EFFECTIVENESS</h2>

<p><strong>Educational Value Assessment:</strong></p>

<h3>1. Phase Indicators:</h3>
<ul>
    <li>✅ Clear visual separation of algorithm stages</li>
    <li>✅ Users understand preprocessing vs optimization vs execution</li>
    <li>✅ Emoji icons make phases memorable</li>
</ul>

<h3>2. Exploration Visualization:</h3>
<ul>
    <li>✅ Blue gradient shows order of node exploration</li>
    <li>✅ Wave effect highlights search frontier</li>
    <li>✅ Students can see how heuristic guides search</li>
</ul>

<h3>3. Metrics Panel:</h3>
<ul>
    <li>✅ Live updates engage users</li>
    <li>✅ Permutations tested counter shows TSP complexity</li>
    <li>✅ Distance tracking shows optimization progress</li>
</ul>

<h3>4. Results Analysis:</h3>
<ul>
    <li>✅ Visual path comparison before/after optimization</li>
    <li>✅ Journey summary makes survivor order explicit</li>
    <li>✅ Statistics provide quantitative understanding</li>
</ul>

<p><strong>User Feedback (Simulated):</strong></p>
<ul>
    <li><em>"Seeing the blue exploration wave helped me understand how A* prioritizes nodes"</em></li>
    <li><em>"Watching 720 routes being tested made factorial complexity real"</em></li>
    <li><em>"The step-by-step visualization is much clearer than pseudocode"</em></li>
</ul>

<!-- SECTION 8: CONCLUSION AND FUTURE SCOPE -->
<div class="page-break"></div>
<h1>8. CONCLUSION AND FUTURE SCOPE</h1>

<h2>8.1 CONCLUSION</h2>

<h3>8.1.1 Achievement Summary:</h3>

<p>This project successfully developed "Rescue Robo," an interactive web application that demonstrates advanced pathfinding and optimization algorithms in an engaging, real-world context. The key achievements include:</p>

<p><strong>1. ALGORITHM IMPLEMENTATION:</strong></p>
<ul>
    <li>Implemented Greedy Best-First Search with Manhattan distance heuristic</li>
    <li>Achieved O(V log V) pathfinding performance on grid graphs</li>
    <li>Developed complete backtracking TSP solver for optimal route planning</li>
    <li>Integrated three-phase algorithm pipeline (preprocessing, optimization, execution)</li>
</ul>

<p><strong>2. EDUCATIONAL VALUE:</strong></p>
<ul>
    <li>Created intuitive visual representations of abstract algorithmic concepts</li>
    <li>Provided real-time exploration visualization showing algorithm decision-making</li>
    <li>Demonstrated the practical impact of time complexity (linear vs factorial)</li>
    <li>Included comprehensive documentation and explanations for beginners</li>
</ul>

<p><strong>3. TECHNICAL EXCELLENCE:</strong></p>
<ul>
    <li>Built responsive, modern web interface using React 18 and TypeScript</li>
    <li>Implemented efficient data structures (priority queues, hash maps, position hashing)</li>
    <li>Created smooth animations with HTML5 Canvas rendering</li>
    <li>Ensured type safety throughout the codebase</li>
</ul>

<p><strong>4. PRACTICAL RELEVANCE:</strong></p>
<ul>
    <li>Modeled realistic emergency response scenario</li>
    <li>Demonstrated applications in disaster relief, logistics, and robotics</li>
    <li>Showed how academic algorithms solve real-world optimization problems</li>
</ul>

<h3>8.1.2 Learning Outcomes:</h3>

<p>Through this project, we gained deep understanding of:</p>
<ul>
    <li>Graph algorithms and heuristic search techniques</li>
    <li>Complexity analysis (time and space)</li>
    <li>Trade-offs between optimality and performance</li>
    <li>Data structure selection and implementation</li>
    <li>Modern web development practices</li>
    <li>Algorithm visualization techniques</li>
</ul>

<p>The project reinforced that while brute-force approaches guarantee optimal solutions, their exponential growth limits practical scalability. For k≤8 survivors, our implementation performs admirably. Beyond this, more sophisticated techniques become necessary.</p>

<h3>8.1.3 Real-World Impact:</h3>

<p>This visualization tool can serve multiple purposes:</p>
<ul>
    <li><strong>Educational:</strong> Teaching aid for DAA courses</li>
    <li><strong>Research:</strong> Benchmark for comparing TSP algorithms</li>
    <li><strong>Planning:</strong> Prototype for actual emergency response software</li>
    <li><strong>Recruitment:</strong> Demonstration of technical skills</li>
</ul>

<h2>8.2 LIMITATIONS</h2>

<h3>8.2.1 Current Constraints:</h3>

<p><strong>1. SCALABILITY:</strong></p>
<ul>
    <li>Limited to ≤8 survivors due to k! growth</li>
    <li>10×10 grid size (can be increased but affects performance)</li>
    <li>No support for weighted edges (all moves cost 1)</li>
</ul>

<p><strong>2. ALGORITHM FEATURES:</strong></p>
<ul>
    <li>No diagonal movement (4-directional only)</li>
    <li>No dynamic obstacle updates during execution</li>
    <li>No priority levels for survivors (all equally important)</li>
    <li>No time windows or deadlines</li>
</ul>

<p><strong>3. VISUALIZATION:</strong></p>
<ul>
    <li>Animation speed limited by browser rendering</li>
    <li>No 3D visualization option</li>
    <li>Limited mobile device support for large grids</li>
</ul>

<p><strong>4. USER EXPERIENCE:</strong></p>
<ul>
    <li>No save/load map functionality</li>
    <li>No undo/redo in editor</li>
    <li>No map sharing via URLs</li>
</ul>

<h2>8.3 FUTURE SCOPE AND ENHANCEMENTS</h2>

<h3>8.3.1 Algorithm Improvements:</h3>

<p><strong>1. ADVANCED TSP SOLVERS:</strong></p>
<ul>
    <li><strong>Implement Held-Karp dynamic programming: O(2^k × k²)</strong>
        <ul>
            <li>Enable solving for k≤20 survivors</li>
            <li>Maintain optimality guarantee</li>
        </ul>
    </li>
    <li><strong>Add Branch-and-Bound pruning:</strong>
        <ul>
            <li>Reduce effective k! by eliminating suboptimal branches early</li>
            <li>Show pruned paths in visualization</li>
        </ul>
    </li>
    <li><strong>Implement approximation algorithms:</strong>
        <ul>
            <li>2-approximation using minimum spanning tree</li>
            <li>Christofides algorithm (1.5-approximation)</li>
            <li>Compare optimal vs approximate solutions</li>
        </ul>
    </li>
</ul>

<p><strong>2. HEURISTIC METHODS:</strong></p>
<ul>
    <li><strong>Genetic Algorithm:</strong>
        <ul>
            <li>Visualize population evolution</li>
            <li>Show crossover and mutation operations</li>
            <li>Animate fitness improvement over generations</li>
        </ul>
    </li>
    <li><strong>Simulated Annealing:</strong>
        <ul>
            <li>Display temperature schedule</li>
            <li>Show acceptance probability calculations</li>
            <li>Visualize solution convergence</li>
        </ul>
    </li>
</ul>

<p><strong>3. PATHFINDING VARIANTS:</strong></p>
<ul>
    <li>A* with consistent heuristic</li>
    <li>Dijkstra's algorithm (for comparison)</li>
    <li>Bidirectional search</li>
    <li>Jump Point Search for large grids</li>
</ul>

<h3>8.3.2 Feature Additions:</h3>

<p><strong>1. ENHANCED MAP EDITOR:</strong></p>
<ul>
    <li>Different terrain types with varying costs (Water: 2×, Roads: 0.5×)</li>
    <li>Weighted survivors (priority levels)</li>
    <li>Map import/export (JSON, URL sharing)</li>
</ul>

<p><strong>2. SIMULATION FEATURES:</strong></p>
<ul>
    <li>Multiple rescue vehicles with team coordination</li>
    <li>Dynamic obstacles with real-time path recalculation</li>
    <li>Time constraints and urgency factors</li>
</ul>

<p><strong>3. VISUALIZATION ENHANCEMENTS:</strong></p>
<ul>
    <li>3D terrain rendering using Three.js</li>
    <li>Augmented Reality mode for mobile devices</li>
    <li>Side-by-side algorithm comparison</li>
    <li>Export animation as video</li>
</ul>

<p><strong>4. EDUCATIONAL TOOLS:</strong></p>
<ul>
    <li>Built-in tutorial mode with guided examples</li>
    <li>Interactive algorithm selection</li>
    <li>Step-by-step code walkthrough</li>
    <li>Quiz mode to test understanding</li>
</ul>

<h3>8.3.3 Technical Improvements:</h3>

<p><strong>1. PERFORMANCE OPTIMIZATION:</strong></p>
<ul>
    <li>Web Workers for background computation</li>
    <li>WebAssembly for critical algorithms (10-100× speed improvement)</li>
    <li>Memoization and caching</li>
</ul>

<p><strong>2. USER EXPERIENCE:</strong></p>
<ul>
    <li>Collaborative map editing (multiplayer)</li>
    <li>Leaderboard for fastest solutions</li>
    <li>Challenge mode with increasing difficulty</li>
    <li>Accessibility features (screen reader, keyboard navigation)</li>
</ul>

<h3>8.3.4 Research Extensions:</h3>

<p><strong>1. MACHINE LEARNING INTEGRATION:</strong></p>
<ul>
    <li>Train neural network to predict optimal routes</li>
    <li>Reinforcement learning for path planning</li>
    <li>Compare ML vs classical algorithms</li>
</ul>

<p><strong>2. REAL-WORLD DATA:</strong></p>
<ul>
    <li>Import actual city maps</li>
    <li>Use real disaster scenarios</li>
    <li>Integrate with GIS systems</li>
</ul>

<h2>8.4 POTENTIAL APPLICATIONS</h2>

<h3>8.4.1 Extended Use Cases:</h3>

<p><strong>1. EMERGENCY SERVICES:</strong></p>
<ul>
    <li>Ambulance dispatch optimization</li>
    <li>Fire truck routing in urban areas</li>
    <li>Evacuation planning tools</li>
    <li>Search and rescue training simulator</li>
</ul>

<p><strong>2. LOGISTICS AND DELIVERY:</strong></p>
<ul>
    <li>Package delivery route planning (last-mile optimization)</li>
    <li>Warehouse robot task scheduling</li>
    <li>Food delivery optimization</li>
    <li>Postal service route planning</li>
</ul>

<p><strong>3. ROBOTICS:</strong></p>
<ul>
    <li>Autonomous vacuum cleaners</li>
    <li>Agricultural harvesting robots</li>
    <li>Inspection drones in industrial facilities</li>
    <li>Automated guided vehicles (AGV) in warehouses</li>
</ul>

<p><strong>4. GAMING AND ENTERTAINMENT:</strong></p>
<ul>
    <li>Educational puzzle games</li>
    <li>Strategy game AI</li>
    <li>Pathfinding in open-world games</li>
    <li>Escape room design tools</li>
</ul>

<h2>8.5 CLOSING REMARKS</h2>

<p>The "Rescue Robo" project demonstrates that complex algorithms can be made accessible and engaging through thoughtful visualization and real-world contextualization. By framing pathfinding and TSP as an emergency rescue mission, we've shown how academic concepts directly impact life-critical situations.</p>

<p>The exponential growth of k! serves as a powerful reminder that algorithmic efficiency matters. While modern computers are incredibly fast, poor algorithm choice can make even simple problems intractable. Our project makes this abstract concept visceral—watching 40,320 routes being tested for just 8 survivors is far more impactful than reading "O(k!)" in a textbook.</p>

<p>Looking forward, the combination of classical algorithms, heuristic methods, and machine learning offers exciting possibilities for solving increasingly complex real-world optimization problems. This project provides a foundation for exploring these advanced techniques.</p>

<p>We hope "Rescue Robo" serves both as an effective learning tool and a demonstration of how computer science can contribute to solving humanity's most pressing challenges—one optimized path at a time.</p>

<!-- APPENDIX -->
<div class="page-break"></div>
<h1>APPENDIX</h1>

<h2>A.1 GLOSSARY OF TERMS</h2>

<table>
    <tr>
        <th style="width: 30%;">Term</th>
        <th>Definition</th>
    </tr>
    <tr>
        <td><strong>A* Algorithm</strong></td>
        <td>Pathfinding algorithm using f(n) = g(n) + h(n)</td>
    </tr>
    <tr>
        <td><strong>Backtracking</strong></td>
        <td>Recursive exhaustive search technique</td>
    </tr>
    <tr>
        <td><strong>Greedy Best-First Search</strong></td>
        <td>A* variant prioritizing h(n) over g(n)</td>
    </tr>
    <tr>
        <td><strong>Heuristic</strong></td>
        <td>Function estimating distance to goal</td>
    </tr>
    <tr>
        <td><strong>Manhattan Distance</strong></td>
        <td>|x₁-x₂| + |y₁-y₂|, valid for grid movement</td>
    </tr>
    <tr>
        <td><strong>TSP</strong></td>
        <td>Traveling Salesman Problem - finding shortest route visiting all points</td>
    </tr>
    <tr>
        <td><strong>Priority Queue</strong></td>
        <td>Data structure retrieving minimum/maximum element efficiently</td>
    </tr>
    <tr>
        <td><strong>Grid Graph</strong></td>
        <td>Graph where nodes are grid cells, edges connect neighbors</td>
    </tr>
</table>

<h2>A.2 REFERENCES</h2>

<ol>
    <li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). <em>Introduction to Algorithms</em> (3rd ed.). MIT Press.</li>
    
    <li>Russell, S., & Norvig, P. (2020). <em>Artificial Intelligence: A Modern Approach</em> (4th ed.). Pearson.</li>
    
    <li>Applegate, D., Bixby, R., Chvátal, V., & Cook, W. (2006). <em>The Traveling Salesman Problem: A Computational Study</em>. Princeton University Press.</li>
    
    <li>Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). A Formal Basis for the Heuristic Determination of Minimum Cost Paths. <em>IEEE Transactions on Systems Science and Cybernetics</em>, 4(2), 100-107.</li>
    
    <li>Held, M., & Karp, R. M. (1962). A Dynamic Programming Approach to Sequencing Problems. <em>Journal of the Society for Industrial and Applied Mathematics</em>, 10(1), 196-210.</li>
</ol>

<h2>A.3 SOURCE CODE REPOSITORY</h2>

<table>
    <tr>
        <th>Resource</th>
        <th>Link</th>
    </tr>
    <tr>
        <td>GitHub Repository</td>
        <td>[Insert repository URL]</td>
    </tr>
    <tr>
        <td>Live Demo</td>
        <td>[Insert deployed application URL]</td>
    </tr>
    <tr>
        <td>Documentation</td>
        <td>[Insert documentation URL]</td>
    </tr>
</table>

<h2>A.4 ACKNOWLEDGMENTS</h2>

<p>We would like to thank:</p>
<ul>
    <li>DAA Lab faculty for guidance and support</li>
    <li>Ramdeobaba University for providing resources</li>
    <li>Open-source community for libraries and tools used</li>
    <li>Beta testers who provided valuable feedback</li>
</ul>

<!-- FOOTER -->
<div class="footer">
    <p><strong>RESCUE ROBO - DAA Lab Project Report</strong></p>
    <p>Ramdeobaba University, Nagpur | Department of Computer Science and Engineering</p>
    <p>© 2025 | Pranav Rathi, Aditya Chapke, Hiten Borkar</p>
</div>

</body>
</html>